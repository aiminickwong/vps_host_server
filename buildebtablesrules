#!/bin/bash


if [ ! -x /usr/local/sbin/ebtables ] && [ ! -x /sbin/ebtables ]; then
       echo 'neither /usr/local/sbin/ebtables nor /sbin/ebtables exist or is not executable';
fi

# don't run on qs
check=`crontab -l | grep qs_cron`;
if [ ! "$check" = "" ]; then
	echo "#skipping for qs";
	service ksm stop
	service ksmtuned stop
	chkconfig ksm off
	chkconfig ksmtuned off
	exit;
fi

debug=0;

#check libvirtd is running
check=`ps auxw | grep "libvirtd --daemon" | grep -v grep`;
if [ "$check" = "" ]; then
        echo "#Libvirtd is not running";

        sleep 1s;
        /etc/init.d/libvirtd restart

        check2=`ps auxw | grep "libvirtd --daemon" | grep -v grep`;
        if [ "$check" = "" ]; then
                echo "Libvirtd did not restart, emailing";
                hostname=`hostname`
                date=`date`;
                echo "Libvirtd is not running on $hostname at $date" | mail -s "libvirt on $hostname not running" hardware@interserver.net
                exit;
        else
                echo "#Libvirtd is running again";
        fi	
else

        echo "#Libvirtd is running";
fi
#endcheck


# interface
hostname=`hostname`
if [ "$hostname" = "kvm1.trouble-free.net" -o "$hostname" = "kvm2.interserver.net" -o "$hostname" = "kvm50.interserver.net" ]; then
	eth=eth1;
else
	eth=eth0;
fi

#bridge
bridge=br0;

# gateway

multi_gw=0;
gw_check=`cat /etc/dhcpd.conf  | grep routers | awk '{print $3}' | cut -d\; -f1 | wc -l`
if [ "$gw_check" -gt "1" ]; then
	multi_gw=1;
	echo "#more than one gw found"
	gateways=`cat /etc/dhcpd.conf  | grep routers | awk '{print $3}' | cut -d\; -f1`;
fi

gateway=`cat /etc/sysconfig/network-scripts/ifcfg-br0 | grep ^GATEWAY= | cut -d= -f2`;
if [ "$gateway" = "" ]; then
	gateway=`cat /etc/sysconfig/network | grep ^GATEWAY= | cut -d= -f2 | tr '\n' '\t'`;
	# still blank?
	if [ "$gateway" = "" ]; then
		gateway=`cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep ^GATEWAY= | cut -d= -f2`;
	fi
fi

br=`ifconfig br0 | grep "inet addr" | cut -d: -f2 | awk '{print $1}'`;

if [ "$DEBUG" = "1" ]; then
	echo "Found br0 on $br and gateway $gateway on eth $eth"
fi


# maybe we want --all?
list=`/usr/bin/virsh list | grep running | awk '{print $2}'`

# output script header
if [ ! "$debug" = "1" ]; then
	cat <<EOF
#!/bin/sh

#Found br0 of $br and gateway $gateway
export PATH=$PATH:/sbin:/usr/local/sbin
/sbin/iptables --flush
iptables -F INPUT
iptables -F OUTPUT
iptables -F FORWARD
echo "1" > /proc/sys/net/ipv4/ip_forward
/sbin/iptables -P INPUT ACCEPT
/sbin/iptables -P OUTPUT ACCEPT
/sbin/iptables -P FORWARD ACCEPT
/sbin/iptables -A INPUT -i lo -j ACCEPT
iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
ebtables -F
ebtables -P INPUT ACCEPT
ebtables -P OUTPUT ACCEPT
ebtables -P FORWARD ACCEPT
EOF
	# end script header
fi

if [ -f /cloud ]; then
	echo "#quickserver exiting";
	exit;
fi
if [ -e /etc/dhcp/dhcpd.vps ]; then
	DHCPVPS=/etc/dhcp/dhcpd.vps
else
	DHCPVPS=/etc/dhcpd.vps
fi
# this outputs all the protection for each individual server
for user in $list; do
	mac=`/usr/bin/virsh dumpxml $user | grep "mac" | grep address | grep : | cut -d\' -f2`;
	dev=`/usr/bin/virsh dumpxml $user | grep target | grep dev | grep vnet | cut -d\' -f2`;
	# improve getting the ip in the future
	ip=`cat $DHCPVPS  | grep "$mac" | awk '{print $8}' | cut -d\; -f1`;
	if [ "$debug" = "1" ]; then
		echo "found user $user"
		echo "	found mac $mac"
		echo "	found dev $dev"
		echo "	found ip $ip"
	else

		###
		# Main Rules
		###
		
		echo "# MAIN RULES"
		echo "# begin $user"
		echo "# $user allow arp, $gateway is gw and $ip is ip of server. $dev changes as well based on server"
	
		# multi gw
		if [ "$multi_gw" = "1" ]; then
			for gw in $gateways; do
				echo "ebtables -A FORWARD -p ARP --arp-ip-src $gw --arp-ip-dst $ip -i $eth -o $dev -j ACCEPT"
				echo "ebtables -A FORWARD -p ARP --arp-ip-src $ip --arp-ip-dst $gw -i $dev -o $eth -j ACCEPT"			
			done
		fi

		# we still run this in multi gw form
		echo "ebtables -A FORWARD -p ARP --arp-ip-src $gateway --arp-ip-dst $ip -i $eth -o $dev -j ACCEPT"
		echo "ebtables -A FORWARD -p ARP --arp-ip-src $ip --arp-ip-dst $gateway -i $dev -o $eth -j ACCEPT"

		echo "ebtables -A FORWARD -p ARP --arp-ip-src $br --arp-ip-dst $ip -i $eth -o $dev -j ACCEPT"
                echo "ebtables -A FORWARD -p ARP --arp-ip-src $ip --arp-ip-dst $br -i $dev -o $eth -j ACCEPT"
		# new addition
                echo "# new addition"
                echo "ebtables -A FORWARD -p ARP -s $mac --arp-ip-src $ip -i $dev -o $eth -j ACCEPT"
                echo "ebtables -A FORWARD -p ARP -s $mac --arp-ip-src $ip -i $eth -o $dev -j ACCEPT"
                # end


		###
		# EXTRA IPS Rules
		###
		#if vps.ipmap is blank we are ignoring this function
		ipcheck=`grep . /root/cpaneldirect/vps.ipmap`;
		if [ ! "$ipcheck" = "" ]; then
			ips="$(grep "^$ip:" /root/cpaneldirect/vps.ipmap | cut -d: -f2)"
			for extraip in $ips; do
				echo "# EXTRA IPS Rules"
				echo "# $user allow arp, $gateway is gw and $extraip is ip of server. $dev changes as well based on server"
				if [ "$multi_gw" = "1" ]; then
					for gw in $gateways; do
						echo "ebtables -A FORWARD -p ARP --arp-ip-src $gw --arp-ip-dst $extraip -i $eth -o $dev -j ACCEPT"
                                        	echo "ebtables -A FORWARD -p ARP --arp-ip-src $extraip --arp-ip-dst $gw -i $dev -o $eth -j ACCEPT"
					done

				fi
				# still run even in multi_gw
				echo "ebtables -A FORWARD -p ARP --arp-ip-src $gateway --arp-ip-dst $extraip -i $eth -o $dev -j ACCEPT"
				echo "ebtables -A FORWARD -p ARP --arp-ip-src $extraip --arp-ip-dst $gateway -i $dev -o $eth -j ACCEPT"

				echo "ebtables -A FORWARD -p ARP --arp-ip-src $br --arp-ip-dst $extraip -i $eth -o $dev -j ACCEPT"
		                echo "ebtables -A FORWARD -p ARP --arp-ip-src $extraip --arp-ip-dst $br -i $dev -o $eth -j ACCEPT"
				# new addition
                                echo "# new addition"
                                echo "ebtables -A FORWARD -p ARP -s $mac --arp-ip-src $extraip -i $dev -o $eth -j ACCEPT"
                                echo "ebtables -A FORWARD -p ARP -s $mac --arp-ip-src $extraip -i $eth -o $dev -j ACCEPT"
                                # end
			done
		fi

		###
		# Ping Local VM Rules
		###
		# new IP PING remote VM
		#ALLOW MYIP:OTHERIP:VPSID
		if [ -e /root/cpaneldirect/tmp/$user ]; then
			data=`grep ^ALLOW /root/cpaneldirect/tmp/$user | cut -d" " -f2-`;
			if [ ! "$data" = "" ]; then
				amyip=`echo $data | cut -d: -f1`;
				atheirip=`echo $data | cut -d: -f2`;
				avpsid=`echo $data | cut -d: -f3`;
				adev=`/usr/bin/virsh dumpxml $avpsid | grep target | grep dev | grep vnet | cut -d\' -f2`;
		
				echo "#allow IP Ping to remote VM"
				echo "ebtables -A FORWARD -p ARP --arp-ip-src $amyip --arp-ip-dst $atheirip -i $dev -o $adev -j ACCEPT"
			fi
		fi
		#end

		###
		# Spoof Protect Rules
		###
		echo "# $user mac spoof protect"
		echo "ebtables -A FORWARD -i $dev -s ! $mac -j DROP"
		echo "# $user IP PROTECT"
		echo "ebtables -A FORWARD -p IPv4 --ip-src $ip -s ! $mac --log-prefix \"$user\" --log-ip --log-arp -j DROP"
		if [ ! "$ips" = "" ]; then
			for extraip in $ips; do
				echo "ebtables -A FORWARD -p IPv4 --ip-src $extraip -s ! $mac --log-prefix \"$user\" --log-ip --log-arp -j DROP"
			done
		fi
		echo "# end $user"
		echo
		
	fi
done

###
# Disable ARP
###

# output final line / footer that disable's arp
if [ ! "$debug" = "1" ]; then
	echo '# DISABLE ARP Rules';
	echo '# dump arp (seems to solve arping ip stealing, what is the draw back?)'
	echo 'ebtables -A FORWARD -p ARP --log-prefix "arp" --log-ip --log-arp -j DROP'
	

	###
	# Block SMTP
	###
	# additional for SMTP disable
	if [ -e /scripts/_tmp/smtp/ ]; then
		cd /scripts/_tmp/smtp
		for i in `ls`; do
			if [ ! "$i" = "" ]; then
				echo '# smtp blocks';
				echo "/admin/kvmenable blocksmtp $i"
			fi
		done
	fi

	###
	# Block IPs
	###
	# additional for ip blocks
	if [ -e /scripts/_tmp/blockip/ ]; then
		cd /scripts/_tmp/blockip
		for i in `ls`; do
                        if [ ! "$i" = "" ]; then
                                echo '# block ips';
                                echo "/admin/kvmenable blockip $i"
                        fi
                done
        fi

fi


if [ -e /proxyarp ]; then
	echo "#enabling proxy arp"
	echo "echo 1 > /proc/sys/net/ipv4/conf/$eth/proxy_arp"
	echo "echo 1 > /proc/sys/net/ipv4/conf/$bridge/proxy_arp"
fi
